.TH "src/include/Lazuli/common.h" 3 "Sun Sep 6 2020" "Lazuli" \" -*- nroff -*-
.ad l
.nh
.SH NAME
src/include/Lazuli/common.h \- Basic type definitions and useful macros\&.  

.SH SYNOPSIS
.br
.PP
\fC#include <stdint\&.h>\fP
.br

.SS "Macros"

.in +1c
.ti -1c
.RI "#define \fB_EXTERN_C_DECL_BEGIN\fP"
.br
.RI "Open C++ header file declarations\&. "
.ti -1c
.RI "#define \fB_EXTERN_C_DECL_END\fP"
.br
.RI "Close C++ header file declarations\&. "
.ti -1c
.RI "#define \fBUNUSED\fP(X)   ((void)(X))"
.br
.RI "Tell the compiler that the variable X is left unsed\&. "
.ti -1c
.RI "#define \fBSTATIC_ASSERT\fP(C,  M)   extern char _static_assertion_##M[(C) ? 1 : \-1]"
.br
.RI "Perform an assertion at compile time\&. "
.ti -1c
.RI "#define \fBNULL\fP   ((void *)0)"
.br
.RI "NULL pointer\&. "
.ti -1c
.RI "#define \fBtrue\fP   ((\fBbool\fP)1)"
.br
.RI "Boolean TRUE constant value\&. "
.ti -1c
.RI "#define \fBfalse\fP   ((\fBbool\fP)0)"
.br
.RI "Boolean FALSE constant value\&. "
.ti -1c
.RI "#define \fBALLOW_ARITHM\fP(X)   ((\fBuint8_t\fP *)(X))"
.br
.RI "Allow arithmetic on a void pointer\&. "
.ti -1c
.RI "#define \fBSTATIC_CHECK_TYPE\fP(V,  T)   \fBUNUSED\fP(1 ? (T*)0 : &(V))"
.br
.RI "Check that the lvalue V is of type T at compile time\&. "
.ti -1c
.RI "#define \fBSET_BITS\fP(V,  T,  X)"
.br
.RI "Set the corresponding bits of X in the value V of type T\&. "
.ti -1c
.RI "#define \fBCLEAR_BITS\fP(V,  T,  X)"
.br
.RI "Clear the corresponding bits of X in the value V of type T\&. "
.ti -1c
.RI "#define \fBPOSITION\fP(X)   (1U << (X))"
.br
.RI "Define a constant bit at position X, starting from index 0\&. "
.ti -1c
.RI "#define \fBINDIRECT_T\fP(X,  T)   ((volatile T *)(X))"
.br
.RI "Define an indirect read/write variable at an absolute address\&. "
.ti -1c
.RI "#define \fBINDIRECT\fP(X)   \fBINDIRECT_T\fP(X, \fBuint8_t\fP)"
.br
.RI "Define an indirect read/write register at an absolute address\&. "
.ti -1c
.RI "#define \fBDIRECT_T\fP(X,  T)   (*\fBINDIRECT_T\fP(X, T))"
.br
.RI "Define a direct read/write variable at an absolute address\&. "
.ti -1c
.RI "#define \fBDIRECT\fP(X)   \fBDIRECT_T\fP(X, \fBuint8_t\fP)"
.br
.RI "Define a direct read/write register at an absolute address\&. "
.ti -1c
.RI "#define \fBLO8\fP(X)   ((\fBuint8_t\fP)(X))"
.br
.RI "Take the low byte of a 16-bit value\&. "
.ti -1c
.RI "#define \fBHI8\fP(X)   \fBLO8\fP((X) >> 8)"
.br
.RI "Take the high byte of a 16-bit value\&. "
.ti -1c
.RI "#define \fBMIN\fP(A,  B)   (((A) < (B)) ? (A) : (B))"
.br
.RI "Obtain the minimum between two integer values\&. "
.ti -1c
.RI "#define \fBMAX\fP(A,  B)   (((A) < (B)) ? (B) : (A))"
.br
.RI "Obtain the maximum between two integer values\&. "
.ti -1c
.RI "#define \fBABS\fP(A)   (((A) < 0) ? (\-(A)) : (A))"
.br
.RI "Obtain the absolute value of an integer\&. "
.ti -1c
.RI "#define \fBOFFSET_OF\fP(M,  T)   ((\fBsize_t\fP)(&(((T*)0)\->M)))"
.br
.RI "Get the offset of a member in a structure\&. "
.ti -1c
.RI "#define \fBCONTAINER_OF\fP(P,  M,  T)   ((T*) ((\fBuint8_t\fP*) (1 ? (P) : &(((T*)0)\->M)) \- \fBOFFSET_OF\fP(M, T)))"
.br
.RI "Get a pointer to the structure T containing the member M pointed by P\&. "
.ti -1c
.RI "#define \fBNAME_OF\fP(X)   #X"
.br
.RI "Convert the name of a symbol to a string\&. "
.ti -1c
.RI "#define \fBELEMENTS_COUNT\fP(X)   ((\fBsize_t\fP)(sizeof(X) / sizeof((X)[0])))"
.br
.RI "Get the number of elements in a statically initialized array\&. "
.ti -1c
.RI "#define \fBDEPENDENCY_ON_MODULE\fP(X)   \fBSTATIC_ASSERT\fP(LZ_CONFIG_MODULE_ ## X ## _USED, Module_ ## X ## _must_be_used)"
.br
.RI "Perform a static assertion to check if a given module is activated\&. "
.in -1c
.SS "Typedefs"

.in +1c
.ti -1c
.RI "typedef int \fBptrdiff_t\fP"
.br
.RI "Represents the difference between two pointers\&. "
.ti -1c
.RI "typedef \fBuint8_t\fP \fBbool\fP"
.br
.RI "Boolean type\&. "
.ti -1c
.RI "typedef \fBuint16_t\fP \fBsize_t\fP"
.br
.RI "Represents the size of an object\&. "
.ti -1c
.RI "typedef \fBuint8_t\fP \fBu_read_write_atomic_t\fP"
.br
.RI "Represents an unsigned integer that can be read and written atomically\&. "
.in -1c
.SH "Detailed Description"
.PP 
Basic type definitions and useful macros\&. 


.PP
\fBCopyright:\fP
.RS 4
2017-2020, Remi Andruccioli remi.andruccioli@gmail.com
.RE
.PP
This file describes basic type definitions and useful macros used in the Lazuli project\&. 
.PP
Definition in file \fBcommon\&.h\fP\&.
.SH "Macro Definition Documentation"
.PP 
.SS "#define UNUSED(X)   ((void)(X))"

.PP
Tell the compiler that the variable X is left unsed\&. 
.PP
\fBParameters:\fP
.RS 4
\fIX\fP The unused variable\&. 
.RE
.PP

.PP
Definition at line 51 of file common\&.h\&.
.SS "#define STATIC_ASSERT(C, M)   extern char _static_assertion_##M[(C) ? 1 : \-1]"

.PP
Perform an assertion at compile time\&. Won't compile if the assertion is false\&.
.PP
\fBParameters:\fP
.RS 4
\fIC\fP The condition to check\&. 
.br
\fIM\fP A C-language identifier used as 'message/name' for the static assertion\&. It's used here to display an informative message directly in the source code and compiler output in case of a failure\&. 
.RE
.PP

.PP
Definition at line 63 of file common\&.h\&.
.SS "#define ALLOW_ARITHM(X)   ((\fBuint8_t\fP *)(X))"

.PP
Allow arithmetic on a void pointer\&. Arithmetic on void pointers isn't allowed in standard C\&.
.PP
\fBParameters:\fP
.RS 4
\fIX\fP The void pointer on which to perform arithmetic\&. 
.RE
.PP

.PP
Definition at line 115 of file common\&.h\&.
.SS "#define STATIC_CHECK_TYPE(V, T)   \fBUNUSED\fP(1 ? (T*)0 : &(V))"

.PP
Check that the lvalue V is of type T at compile time\&. 
.PP
\fBParameters:\fP
.RS 4
\fIV\fP The lvalue to check\&. 
.br
\fIT\fP The supposed type of the lvalue\&. 
.RE
.PP

.PP
Definition at line 133 of file common\&.h\&.
.SS "#define SET_BITS(V, T, X)"
\fBValue:\fP
.PP
.nf
do {                                              \
    STATIC_CHECK_TYPE(V, T);                        \
    (V) |= (T)(X);                                  \
  } while (0)
.fi
.PP
Set the corresponding bits of X in the value V of type T\&. 
.PP
\fBParameters:\fP
.RS 4
\fIV\fP The value to set bits\&. 
.br
\fIT\fP The type of the value V\&. 
.br
\fIX\fP A value containing the bits (at logical 1) to set\&. 
.RE
.PP

.PP
Definition at line 142 of file common\&.h\&.
.SS "#define CLEAR_BITS(V, T, X)"
\fBValue:\fP
.PP
.nf
do {                                          \
    STATIC_CHECK_TYPE(V, T);                    \
    (V) &= (T)(~(X));                           \
  } while (0)
.fi
.PP
Clear the corresponding bits of X in the value V of type T\&. 
.PP
\fBParameters:\fP
.RS 4
\fIV\fP The value to set bits\&. 
.br
\fIT\fP The type of the value V\&. 
.br
\fIX\fP A value containing the bits (at logical 1) to clear\&. 
.RE
.PP

.PP
Definition at line 155 of file common\&.h\&.
.SS "#define POSITION(X)   (1U << (X))"

.PP
Define a constant bit at position X, starting from index 0\&. 
.PP
\fBParameters:\fP
.RS 4
\fIX\fP An unsigned integer constant representing the position of the bit, starting from index 0\&.
.RE
.PP
\fBWarning:\fP
.RS 4
The constant must be specified using an unsigned integer litteral in uppercase\&. e\&.g\&. \fBPOSITION(2U)\fP This is to make static analyzers not complain about using a shift operator with an unsigned value\&. 
.RE
.PP

.PP
Definition at line 173 of file common\&.h\&.
.SS "#define INDIRECT_T(X, T)   ((volatile T *)(X))"

.PP
Define an indirect read/write variable at an absolute address\&. i\&.e\&. A variable that is accessed through a pointer\&.
.PP
\fBParameters:\fP
.RS 4
\fIX\fP The address of the variable\&. 
.br
\fIT\fP The type of the variable\&. 
.RE
.PP

.PP
Definition at line 182 of file common\&.h\&.
.SS "#define INDIRECT(X)   \fBINDIRECT_T\fP(X, \fBuint8_t\fP)"

.PP
Define an indirect read/write register at an absolute address\&. i\&.e\&. A register that is accessed through a pointer\&.
.PP
\fBParameters:\fP
.RS 4
\fIX\fP The address of the register\&. 
.RE
.PP

.PP
Definition at line 190 of file common\&.h\&.
.SS "#define DIRECT_T(X, T)   (*\fBINDIRECT_T\fP(X, T))"

.PP
Define a direct read/write variable at an absolute address\&. 
.PP
\fBParameters:\fP
.RS 4
\fIX\fP The address of the variable\&. 
.br
\fIT\fP The type of the variable\&. 
.RE
.PP

.PP
Definition at line 198 of file common\&.h\&.
.SS "#define DIRECT(X)   \fBDIRECT_T\fP(X, \fBuint8_t\fP)"

.PP
Define a direct read/write register at an absolute address\&. 
.PP
\fBParameters:\fP
.RS 4
\fIX\fP The address of the register\&. 
.RE
.PP

.PP
Definition at line 205 of file common\&.h\&.
.SS "#define LO8(X)   ((\fBuint8_t\fP)(X))"

.PP
Take the low byte of a 16-bit value\&. 
.PP
\fBParameters:\fP
.RS 4
\fIX\fP The 16-bit value\&. 
.RE
.PP

.PP
Definition at line 212 of file common\&.h\&.
.SS "#define HI8(X)   \fBLO8\fP((X) >> 8)"

.PP
Take the high byte of a 16-bit value\&. 
.PP
\fBParameters:\fP
.RS 4
\fIX\fP The 16-bit value\&. 
.RE
.PP

.PP
Definition at line 219 of file common\&.h\&.
.SS "#define MIN(A, B)   (((A) < (B)) ? (A) : (B))"

.PP
Obtain the minimum between two integer values\&. 
.PP
\fBParameters:\fP
.RS 4
\fIA\fP The first value\&. 
.br
\fIB\fP The second value\&. 
.RE
.PP

.PP
Definition at line 227 of file common\&.h\&.
.SS "#define MAX(A, B)   (((A) < (B)) ? (B) : (A))"

.PP
Obtain the maximum between two integer values\&. 
.PP
\fBParameters:\fP
.RS 4
\fIA\fP The first value\&. 
.br
\fIB\fP The second value\&. 
.RE
.PP

.PP
Definition at line 235 of file common\&.h\&.
.SS "#define ABS(A)   (((A) < 0) ? (\-(A)) : (A))"

.PP
Obtain the absolute value of an integer\&. 
.PP
\fBParameters:\fP
.RS 4
\fIA\fP The integer value\&. 
.RE
.PP

.PP
Definition at line 242 of file common\&.h\&.
.SS "#define OFFSET_OF(M, T)   ((\fBsize_t\fP)(&(((T*)0)\->M)))"

.PP
Get the offset of a member in a structure\&. 
.PP
\fBParameters:\fP
.RS 4
\fIM\fP The name of the member\&. 
.br
\fIT\fP The type of the structure\&. 
.RE
.PP

.PP
Definition at line 250 of file common\&.h\&.
.SS "#define CONTAINER_OF(P, M, T)   ((T*) ((\fBuint8_t\fP*) (1 ? (P) : &(((T*)0)\->M)) \- \fBOFFSET_OF\fP(M, T)))"

.PP
Get a pointer to the structure T containing the member M pointed by P\&. May not compile if P doesn't point to the type defined by M\&.
.PP
\fBParameters:\fP
.RS 4
\fIP\fP The pointer to the member\&. 
.br
\fIM\fP The name of the member\&. 
.br
\fIT\fP The type of the structure\&. 
.RE
.PP

.PP
Definition at line 262 of file common\&.h\&.
.SS "#define NAME_OF(X)   #X"

.PP
Convert the name of a symbol to a string\&. 
.PP
\fBParameters:\fP
.RS 4
\fIX\fP The symbol name to convert\&. 
.RE
.PP

.PP
Definition at line 270 of file common\&.h\&.
.SS "#define ELEMENTS_COUNT(X)   ((\fBsize_t\fP)(sizeof(X) / sizeof((X)[0])))"

.PP
Get the number of elements in a statically initialized array\&. 
.PP
\fBParameters:\fP
.RS 4
\fIX\fP The array variable\&. 
.RE
.PP

.PP
Definition at line 277 of file common\&.h\&.
.SS "#define DEPENDENCY_ON_MODULE(X)   \fBSTATIC_ASSERT\fP(LZ_CONFIG_MODULE_ ## X ## _USED, Module_ ## X ## _must_be_used)"

.PP
Perform a static assertion to check if a given module is activated\&. 
.PP
\fBParameters:\fP
.RS 4
\fIX\fP The module name, in uppercase\&. 
.RE
.PP

.PP
Definition at line 284 of file common\&.h\&.
.SH "Typedef Documentation"
.PP 
.SS "typedef \fBuint8_t\fP \fBu_read_write_atomic_t\fP"

.PP
Represents an unsigned integer that can be read and written atomically\&. This type is the equivalent of libc's sig_atomic_t (signal\&.h)\&.
.PP
Use this type with volatile\&. 
.PP
Definition at line 106 of file common\&.h\&.
.SH "Author"
.PP 
Generated automatically by Doxygen for Lazuli from the source code\&.
