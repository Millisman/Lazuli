.TH "src/include/Lazuli/sys/arch/arch.h" 3 "Sun Sep 6 2020" "Lazuli" \" -*- nroff -*-
.ad l
.nh
.SH NAME
src/include/Lazuli/sys/arch/arch.h \- Architecture Abstraction API\&.  

.SH SYNOPSIS
.br
.PP
\fC#include <stdint\&.h>\fP
.br
\fC#include <Lazuli/common\&.h>\fP
.br
\fC#include <Lazuli/list\&.h>\fP
.br
\fC#include <Lazuli/serial\&.h>\fP
.br
\fC#include <Lazuli/sys/compiler\&.h>\fP
.br

.SS "Typedefs"

.in +1c
.ti -1c
.RI "typedef \fBuint8_t\fP \fBInterruptsStatus\fP"
.br
.RI "Define the type used to store interrupts status\&. "
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "void \fBArch_InfiniteLoop\fP (void)"
.br
.RI "Function that loops forever, never returns\&. "
.ti -1c
.RI "void \fBArch_ResetSystem\fP (void)"
.br
.RI "Reset the whole system\&. "
.ti -1c
.RI "void \fBArch_RestoreContextAndReturnFromInterrupt\fP (void *stackPointer)"
.br
.RI "Restore the context of a previously saved task, and run it by returning from interrupt\&. "
.ti -1c
.RI "void \fBArch_StartRunning\fP (void *stackPointer, \fBsize_t\fP offsetOfPc)"
.br
.RI "Start running the scheduler for the first time with the specified context\&. "
.ti -1c
.RI "void \fBArch_LoadFromProgmem\fP (const void *source, void *destination, const \fBsize_t\fP size)"
.br
.RI "Copy bytes from program memory to RAM\&. "
.ti -1c
.RI "\fBuint8_t\fP \fBArch_LoadU8FromProgmem\fP (const void *source)"
.br
.RI "Return a byte stored in program memory\&. "
.ti -1c
.RI "\fBuint16_t\fP \fBArch_LoadU16FromProgmem\fP (const void *source)"
.br
.RI "Return a double-byte word stored in program memory\&. "
.ti -1c
.RI "void * \fBArch_LoadPointerFromProgmem\fP (const void *source)"
.br
.RI "Return a pointer stored in program memory\&. "
.ti -1c
.RI "void \fBArch_DisableInterrupts\fP (void)"
.br
.RI "Disable all interrupts\&. "
.ti -1c
.RI "void \fBArch_EnableInterrupts\fP (void)"
.br
.RI "Enable all interrupts\&. "
.ti -1c
.RI "\fBInterruptsStatus\fP \fBArch_DisableInterruptsGetStatus\fP (void)"
.br
.RI "Disable all interrupts and return the previous interrupts status\&. "
.ti -1c
.RI "void \fBArch_RestoreInterruptsStatus\fP (const \fBInterruptsStatus\fP interruptsStatus)"
.br
.RI "Restore a previously saved interrupts status\&. "
.ti -1c
.RI "\fBbool\fP \fBArch_AreInterruptsEnabled\fP (void)"
.br
.RI "Obtain a value indicating if global interrupts are enabled\&. "
.ti -1c
.RI "void \fBArch_InitIdleCpuMode\fP (void)"
.br
.RI "Initialize idle CPU modes\&. "
.ti -1c
.RI "void \fBArch_CpuSleep\fP (void)"
.br
.RI "Put the CPU to sleep according to the sleep settings\&. "
.ti -1c
.RI "void \fBArch_InitInstrumentation\fP (void)"
.br
.RI "Initialize the context switch instrumentation\&. "
.in -1c
.PP
.RI "\fBSystem timer\fP"
.br

.in +1c
.in +1c
.ti -1c
.RI "void \fBArch_InitSystemTimer\fP (void)"
.br
.RI "Initialize the system timer\&. "
.ti -1c
.RI "void \fBArch_StartSystemTimer\fP (void)"
.br
.RI "Start the system timer\&. "
.in -1c
.in -1c
.PP
.RI "\fBMutex\fP"
.br

.in +1c
.in +1c
.ti -1c
.RI "\fBbool\fP \fBArch_TryAcquireLock\fP (volatile \fBuint8_t\fP *const lock)"
.br
.RI "Try to acquire a lock by atomically changing the value pointed by the lock parameter\&. "
.in -1c
.in -1c
.PP
.RI "\fBSerial\fP"
.br

.in +1c
.in +1c
.ti -1c
.RI "void \fBArch_GetSerialConfiguration\fP (\fBLz_SerialConfiguration\fP *const configuration)"
.br
.RI "Retrieve the current configuration of the serial line\&. "
.ti -1c
.RI "void \fBArch_SetSerialConfiguration\fP (const \fBLz_SerialConfiguration\fP *const configuration)"
.br
.RI "Configure the seria line according to the parameter\&. "
.ti -1c
.RI "void \fBArch_InitSerial\fP (void)"
.br
.RI "Initialize serial line with default configuration at system startup\&. "
.in -1c
.in -1c
.SS "Variables"

.in +1c
.ti -1c
.RI "void(*)(void) \fBArch_LoadFunctionPointerFromProgmem\fP (const void *source)"
.br
.RI "Return a function pointer stored in program memory\&. "
.in -1c
.SH "Detailed Description"
.PP 
Architecture Abstraction API\&. 


.PP
\fBCopyright:\fP
.RS 4
2017-2020, Remi Andruccioli remi.andruccioli@gmail.com
.RE
.PP
Provides a simple abstraction API to architecture specific functions\&. This is the API that must be re-implemented if porting to another platform\&.
.PP
This one is taylored after the AVR platform and can be subject to change if porting to another platform\&. 
.PP
Definition in file \fBarch\&.h\fP\&.
.SH "Typedef Documentation"
.PP 
.SS "typedef \fBuint8_t\fP \fBInterruptsStatus\fP"

.PP
Define the type used to store interrupts status\&. You shall ALWAYS set a variable of this type by calling \fBArch_DisableInterruptsGetStatus()\fP, and NEVER modify its value manually\&. 
.PP
Definition at line 154 of file arch\&.h\&.
.SH "Function Documentation"
.PP 
.SS "void Arch_RestoreContextAndReturnFromInterrupt (void * stackPointer)"

.PP
Restore the context of a previously saved task, and run it by returning from interrupt\&. The context of a task is saved on its stack\&. Consists in restoring all of the registers (including the state register) and continue execution of the task by performing a \fCreturn from interrupt\fP, as the program counter has previously been saved on the stack by hardware\&.
.PP
\fBParameters:\fP
.RS 4
\fIstackPointer\fP The stack pointer of the task to restore\&. 
.RE
.PP

.SS "void Arch_StartRunning (void * stackPointer, \fBsize_t\fP offsetOfPc)"

.PP
Start running the scheduler for the first time with the specified context\&. This function simply ignores all the registers in the context, and jumps directly to the saved return address\&.
.PP
\fBParameters:\fP
.RS 4
\fIstackPointer\fP The stack pointer of the task to run, containing its prepared context\&. 
.br
\fIoffsetOfPc\fP The offset of the PC member in the \fBTaskContextLayout\fP structure (i\&.e\&. the saved context of the task)\&. 
.RE
.PP

.SS "void Arch_LoadFromProgmem (const void * source, void * destination, const \fBsize_t\fP size)"

.PP
Copy bytes from program memory to RAM\&. 
.PP
\fBParameters:\fP
.RS 4
\fIsource\fP A pointer to the source address in program memory\&. 
.br
\fIdestination\fP A pointer to the destination address in RAM\&. 
.br
\fIsize\fP The number of bytes to copy\&. 
.RE
.PP

.SS "\fBuint8_t\fP Arch_LoadU8FromProgmem (const void * source)"

.PP
Return a byte stored in program memory\&. 
.PP
\fBWarning:\fP
.RS 4
The return type is unsigned\&.
.RE
.PP
\fBParameters:\fP
.RS 4
\fIsource\fP A pointer to the byte stored in program memory\&.
.RE
.PP
\fBReturns:\fP
.RS 4
The byte value stored at the address contained in source parameter\&. 
.RE
.PP

.SS "\fBuint16_t\fP Arch_LoadU16FromProgmem (const void * source)"

.PP
Return a double-byte word stored in program memory\&. 
.PP
\fBWarning:\fP
.RS 4
The return type is unsigned\&.
.RE
.PP
\fBParameters:\fP
.RS 4
\fIsource\fP A pointer to the word stored in program memory\&.
.RE
.PP
\fBReturns:\fP
.RS 4
The word value stored at the address contained in source parameter\&. 
.RE
.PP

.SS "void* Arch_LoadPointerFromProgmem (const void * source)"

.PP
Return a pointer stored in program memory\&. 
.PP
\fBParameters:\fP
.RS 4
\fIsource\fP A pointer to the pointer stored in program memory\&.
.RE
.PP
\fBReturns:\fP
.RS 4
The pointer value stored at the address contained in source parameter\&. 
.RE
.PP

.SS "\fBInterruptsStatus\fP Arch_DisableInterruptsGetStatus (void)"

.PP
Disable all interrupts and return the previous interrupts status\&. 
.PP
\fBReturns:\fP
.RS 4
The previous global interrupts status\&. 
.RE
.PP

.SS "void Arch_RestoreInterruptsStatus (const \fBInterruptsStatus\fP interruptsStatus)"

.PP
Restore a previously saved interrupts status\&. 
.PP
\fBParameters:\fP
.RS 4
\fIinterruptsStatus\fP A previously saved InterruptsStatus\&. 
.RE
.PP

.SS "\fBbool\fP Arch_AreInterruptsEnabled (void)"

.PP
Obtain a value indicating if global interrupts are enabled\&. 
.PP
\fBReturns:\fP
.RS 4
: - true if global interrupts are enabled
.IP "\(bu" 2
false if global interrupts are disabled 
.PP
.RE
.PP

.SS "\fBbool\fP Arch_TryAcquireLock (volatile \fBuint8_t\fP *const lock)"

.PP
Try to acquire a lock by atomically changing the value pointed by the lock parameter\&. 
.PP
\fBParameters:\fP
.RS 4
\fIlock\fP A pointer to the lock\&.
.RE
.PP
\fBReturns:\fP
.RS 4
- true if the lock was free, hence it could be acquired
.IP "\(bu" 2
false if the lock wasn't free, hence it couldn't be acquired 
.PP
.RE
.PP

.SS "void Arch_GetSerialConfiguration (\fBLz_SerialConfiguration\fP *const configuration)"

.PP
Retrieve the current configuration of the serial line\&. 
.PP
\fBParameters:\fP
.RS 4
\fIconfiguration\fP A pointer to an allocated \fBLz_SerialConfiguration\fP used to store the configuration\&. 
.RE
.PP

.PP
Definition at line 544 of file usart\&.c\&.
.SS "void Arch_SetSerialConfiguration (const \fBLz_SerialConfiguration\fP *const configuration)"

.PP
Configure the seria line according to the parameter\&. 
.PP
\fBParameters:\fP
.RS 4
\fIconfiguration\fP A pointer to an existing \fBLz_SerialConfiguration\fP containg the full configuration to set up the serial line\&. 
.RE
.PP

.PP
Definition at line 554 of file usart\&.c\&.
.SS "void Arch_InitSerial (void)"

.PP
Initialize serial line with default configuration at system startup\&. < member: enableFlags
.PP
< member: stopBits
.PP
< member: parityBits
.PP
< member: size
.PP
< member: speed 
.PP
Definition at line 583 of file usart\&.c\&.
.SH "Variable Documentation"
.PP 
.SS "void(*)(void) Arch_LoadFunctionPointerFromProgmem(const void *source)"

.PP
Return a function pointer stored in program memory\&. 
.PP
\fBWarning:\fP
.RS 4
To use this function with a different prototype than void (*)(void), the return value must be cast to the appropriate function pointer type\&. We can't use \fBArch_LoadPointerFromProgmem()\fP to do the same thing because ISO C forbids assignment between function pointer and 'void *', and conversion of object pointer to function pointer type\&.
.RE
.PP
\fBParameters:\fP
.RS 4
\fIsource\fP A pointer to the function pointer stored in program memory\&.
.RE
.PP
\fBReturns:\fP
.RS 4
The function pointer value stored at the address contained in source parameter\&. 
.RE
.PP

.PP
Definition at line 133 of file arch\&.h\&.
.SH "Author"
.PP 
Generated automatically by Doxygen for Lazuli from the source code\&.
